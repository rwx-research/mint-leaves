name: mint/git-clone
version: 1.3.0
description: Clone git repositories over ssh or http, with support for Git Large File Storage (LFS)
source_code_url: https://github.com/rwx-research/mint-leaves/tree/main/mint/git-clone
issue_tracker_url: https://github.com/rwx-research/mint-leaves/issues

parameters:
  github-access-token:
    description: "Token to clone from GitHub over HTTPS"
    required: false
  lfs:
    description: Whether to download Git-LFS files
    default: false
  path:
    description: "The relative path within the workspace into which the repository will be cloned"
    default: "./"
  preserve-git-dir:
    description: "Whether or not to preserve the .git directory. Set to true if you want to perform git operations like committing after cloning. Preserving the .git directory will decreaes the likelihood of cache hits when a file filter is not specified."
    default: false
  ref:
    description: "The ref to check out of the git repository"
    required: true
  meta-ref:
    description: "The unresolved name of the ref being checked out (used to set MINT_GIT_REF_NAME). e.g. refs/heads/main or refs/tags/v1.0.0"
    required: false
  repository:
    description: "The url of a git repository."
    required: true
  ssh-key:
    description: "The ssh key to use if cloning over ssh"
    required: false

tasks:
  - key: setup
    run: |
      sudo install $MINT_LEAF_PATH/bin/git-ssh-command /usr/local/bin
      echo "git-ssh-command" >> $MINT_ENV/GIT_SSH_COMMAND
      if [[ -n "$GIT_SSH_KEY" ]]; then
        httpRegex="https?:\/\/"
        if [[ "$CHECKOUT_REPOSITORY" =~ $httpRegex ]]; then
          errorMessage=$(mktemp "$MINT_ERRORS/error-XXXX")
          cat << EOF > $errorMessage
      Invalid parameters: \`repository\` points to an HTTP URL, but \`ssh-key\` was set.

      The current value is \`$CHECKOUT_REPOSITORY\`.
      EOF
          githubRegex="https?:\/\/github.com\/(.*)\/(.*)\.git"
          if [[ $CHECKOUT_REPOSITORY =~ $githubRegex ]]; then
            org="${BASH_REMATCH[1]}"
            repo="${BASH_REMATCH[2]}"

            truncate -s-1 $errorMessage
            echo " Perhaps you meant \`git@github.com:$org/$repo.git\`?" >> $errorMessage
          fi
          exit 2
        fi

        echo -n "" > $MINT_VALUES/credentials-arg
      else
        if [[ "$CHECKOUT_REPOSITORY" != http* ]]; then
          errorMessage=$(mktemp "$MINT_ERRORS/error-XXXX")
          cat << EOF > $errorMessage
      Invalid parameters: \`repository\` must point to an HTTP URL if \`ssh-key\` is not set.

      The current value is \`$CHECKOUT_REPOSITORY\`.
      EOF
          githubRegex="git@github.com:(.*)\/(.*).git"
          if [[ $CHECKOUT_REPOSITORY =~ $githubRegex ]]; then
            org="${BASH_REMATCH[1]}"
            repo="${BASH_REMATCH[2]}"

            truncate -s-1 $errorMessage
            echo " Perhaps you meant \`https://github.com/$org/$repo.git\`?" >> $errorMessage
          fi
          exit 2
        fi

        echo "Setting credential.helper to clone using github-access-token"
        echo -n "-c credential.helper='!bash -c \"echo username=x-access-token && echo password=\${GITHUB_TOKEN}\"'" > $MINT_VALUES/credentials-arg
      fi
    env:
      GIT_SSH_KEY: ${{ params.ssh-key }}
      CHECKOUT_REPOSITORY: ${{ params.repository }}

  - key: get-latest-sha-for-ref
    use: setup
    run: |
      LATEST_SHA_CACHE_BUSTER=$(git ${{ tasks.setup.values.credentials-arg }} ls-remote "${CHECKOUT_REPOSITORY}" "${CHECKOUT_REF}" | awk '{print $1}')
      if [[ $LATEST_SHA_CACHE_BUSTER == "" ]]; then
        LATEST_SHA_CACHE_BUSTER="${CHECKOUT_REF}"
      fi
      echo "Latest SHA for ${CHECKOUT_REF}: ${LATEST_SHA_CACHE_BUSTER}"
      printf "${LATEST_SHA_CACHE_BUSTER}" >> "$MINT_VALUES/latest-sha-cache-buster"
    env:
      GIT_SSH_KEY:
        value: ${{ params.ssh-key }}
        cache-key: excluded
      GITHUB_TOKEN:
        value: ${{ params.github-access-token }}
        cache-key: excluded
      CHECKOUT_REF: ${{ params.ref }}
      CHECKOUT_REPOSITORY: ${{ params.repository }}
    cache: ${{ params.ref =~ '^[0-9a-f]{40}$' }}

  - key: install-lfs
    run: |
      if [[ "${LFS}" != "true" ]]; then
        echo "params.lfs is false; skipping lfs install"
        exit 0
      fi

      sudo apt-get update
      sudo apt-get install git-lfs
      sudo apt-get clean
    env:
      LFS: ${{ params.lfs }}

  - key: git-clone
    use: [setup, install-lfs]
    run: |
      git clone ${{ tasks.setup.values.credentials-arg }} "${CHECKOUT_REPOSITORY}" "${CHECKOUT_PATH}"
      cd "${CHECKOUT_PATH}"

      git checkout "${CHECKOUT_REF}"

      commit_sha=$(git rev-parse HEAD | tr -d '\n')
      echo "Checked out git repository at ${commit_sha}"

      if [[ "${LFS}" == "true" ]]; then
        LFS_FILES=$(git-lfs ls-files -n)
        if [[ "${LFS_FILES}" != "" ]]; then
          FILTER_PATH_PREFIX="${CHECKOUT_PATH%/}/"
          FILTER_LINES=$(echo "$LFS_FILES" | jq -c --raw-input --slurp --arg prefix "$FILTER_PATH_PREFIX" 'split("\n") | map(select(. != "") | $prefix + .)')

          cat << EOF > $MINT_DYNAMIC_TASKS/lfs.yml
      - key: lfs-files
        use: configure-git
        run: |
          cd "\${CHECKOUT_PATH}"

          DOWNLOAD_HEADERS=(
            "Accept: application/vnd.git-lfs+json"
            "Content-Type: application/json"
          )

          if [[ -n "\$GIT_SSH_KEY" ]]; then
            SSH_PART=\$(echo "\$CHECKOUT_REPOSITORY" | sed 's/:.*//')
            REPO_PART=\$(echo "\$CHECKOUT_REPOSITORY" | sed 's/.*://')

            SSH_CREDENTIALS=\$(git-ssh-command \$SSH_PART git-lfs-authenticate \$REPO_PART download)
            DYNAMIC_HEADERS=\$(echo "\$SSH_CREDENTIALS" | jq -r '.header | to_entries | .[] | "\\(.key): \\(.value)"')
            while read -r header; do
              DOWNLOAD_HEADERS+=("\$header")
            done <<< "\$DYNAMIC_HEADERS"
          else
            DOWNLOAD_HEADERS+=("Authorization: Bearer \$GITHUB_TOKEN")
          fi

          LFS_FILES_ARRAY=(\$LFS_FILES)

          for file in \${LFS_FILES_ARRAY[@]}; do
            while read -r line; do
              case \$line in
                version*) VERSION=\$(echo \$line | awk '{print \$2}') ;;
                oid*) SHA256=\$(echo \$line | awk '{print \$2}' | cut -d ':' -f 2) ;;
                size*) SIZE=\$(echo \$line | awk '{print \$2}') ;;
              esac
            done < \$file

            CURL_COMMAND="curl -X POST"
            for header in "\${DOWNLOAD_HEADERS[@]}"; do
              CURL_COMMAND+=" -H \\"\$header\\""
            done
            URL="https://github.com/\$MINT_GIT_REPOSITORY_NAME.git/info/lfs/objects/batch"
            DATA="{\\"operation\\": \\"download\\", \\"transfer\\": [\\"basic\\"], \\"objects\\": [{\\"oid\\": \\"\$SHA256\\", \\"size\\": \$SIZE}]}"
            CURL_COMMAND+=" -d '\$DATA' \$URL"

            DOWNLOAD_URL=\$(eval "\$CURL_COMMAND" | jq -r '.objects[0].actions.download.href')

            curl -o "\$file" "\$DOWNLOAD_URL"
          done
        env:
          CHECKOUT_REPOSITORY: \\\${{ params.repository }}
          GIT_SSH_KEY:
            value: \\\${{ params.ssh-key }}
            cache-key: excluded
          GITHUB_TOKEN:
            value: \\\${{ params.github-access-token }}
            cache-key: excluded
          LFS_FILES: $LFS_FILES
          CHECKOUT_PATH: \\\${{ params.path }}
          PRESERVE_GIT_DIR: \\\${{ params.preserve-git-dir }}
        filter: ${FILTER_LINES}
      EOF
            if [[ "${PRESERVE_GIT_DIR}" == "true" ]]; then
              cat << EOF > $MINT_DYNAMIC_TASKS/lfs-cleanup.yml
      - key: lfs-cleanup
        use: lfs-files
        run: git add -Av
      EOF
          fi
        fi
      fi

      # Set metadata
      printf "%s" "${CHECKOUT_REPOSITORY}" >> "$MINT_CACHE_KEY_EXCLUDED_ENV/MINT_GIT_REPOSITORY_URL"
      printf "%s" "${CHECKOUT_REPOSITORY}" | tr ':' '/' | rev | cut -d '/' -f1,2 | rev | sed 's/\.git$//' >> "$MINT_CACHE_KEY_EXCLUDED_ENV/MINT_GIT_REPOSITORY_NAME"

      commit_message=$(git log -n 1 --pretty=format:%B)
      printf "%s" "${commit_message}" >> "$MINT_CACHE_KEY_EXCLUDED_ENV/MINT_GIT_COMMIT_MESSAGE"
      printf "%s" "${commit_message}" | head -n 1 | tr -d '\n' >> "$MINT_CACHE_KEY_EXCLUDED_ENV/MINT_GIT_COMMIT_SUMMARY"

      committer_name=$(git log -n 1 --pretty=format:%an)
      printf "%s" "${committer_name}" >> "$MINT_CACHE_KEY_EXCLUDED_ENV/MINT_GIT_COMMITTER_NAME"

      committer_email=$(git log -n 1 --pretty=format:%ae)
      printf "%s" "${committer_email}" >> "$MINT_CACHE_KEY_EXCLUDED_ENV/MINT_GIT_COMMITTER_EMAIL"

      unresolved_ref=""
      if [[ -n "${META_REF}" ]]; then
        refs_matching_provided_ref=$(git ls-remote --heads --tags origin | grep "refs/heads/${META_REF}\|refs/tags/${META_REF}\|${META_REF}" | awk '{ print $2; }')
        unresolved_ref=$(echo "$refs_matching_provided_ref" | head -n 1 | tr -d '\n')

        # also, ensure the meta-ref contains the resolved commit sha
        # first fetch the ref so it will appear in git for-each-ref under refs/heads or refs/tags
        git fetch origin "${unresolved_ref}:${unresolved_ref}"
        result=$(git for-each-ref "${unresolved_ref}" --format="%(refname)" --contains "${commit_sha}")
        if [[ -z "${result}" ]]; then
          cat << EOF > $(mktemp "$MINT_ERRORS/error-XXXX")
      The \`meta-ref\` provided does not contain the resolved commit sha.
      EOF
          exit 1
        fi
      elif [[ "${CHECKOUT_REF}" == "${commit_sha}" ]]; then
        refs_with_sha_at_head=$(git ls-remote --heads --tags origin | awk "\$1 ~ /^${commit_sha}/" | awk '{ print $2; }')
        unresolved_ref=$(echo "$refs_with_sha_at_head" | head -n 1 | tr -d '\n')
      else
        refs_matching_provided_ref=$(git ls-remote  --heads --tags origin | grep "refs/heads/${CHECKOUT_REF}\|refs/tags/${CHECKOUT_REF}\|${CHECKOUT_REF}" | awk '{ print $2; }')
        unresolved_ref=$(echo "$refs_matching_provided_ref" | head -n 1 | tr -d '\n')
      fi

      if [[ -z "${unresolved_ref}" ]]; then
        unresolved_ref="${commit_sha}"
      fi

      printf "%s" "${commit_sha}" >> "$MINT_CACHE_KEY_EXCLUDED_ENV/MINT_GIT_COMMIT_SHA"
      printf "%s" "${unresolved_ref}" >> "$MINT_CACHE_KEY_EXCLUDED_ENV/MINT_GIT_REF"
      printf "%s" "${unresolved_ref}" | sed -E 's|refs/[^/]+/||' >> "$MINT_CACHE_KEY_EXCLUDED_ENV/MINT_GIT_REF_NAME"

      if [[ "${PRESERVE_GIT_DIR}" == "false" ]]; then
        rm -rf .git
      fi
    env:
      GIT_LFS_SKIP_SMUDGE: 1
      CACHE_BUST: ${{ tasks.get-latest-sha-for-ref.values.latest-sha-cache-buster }}
      GIT_SSH_KEY:
        value: ${{ params.ssh-key }}
        cache-key: excluded
      GITHUB_TOKEN:
        value: ${{ params.github-access-token }}
        cache-key: excluded
      CHECKOUT_PATH: ${{ params.path }}
      CHECKOUT_REF: ${{ params.ref }}
      CHECKOUT_REPOSITORY: ${{ params.repository }}
      META_REF: ${{ params.meta-ref }}
      LFS: ${{ params.lfs }}
      PRESERVE_GIT_DIR: ${{ params.preserve-git-dir }}

  - key: configure-git
    use: [git-clone]
    run: |
      if [[ "${PRESERVE_GIT_DIR}" == "false" ]]; then
        exit 0
      fi
      if [[ -z "$GITHUB_TOKEN" ]]; then
        exit 0
      fi
      cd "${CHECKOUT_PATH}"

      git config credential.helper '!bash -c "echo username=x-access-token && echo password=${GITHUB_TOKEN}"'

      QUERY="query { viewer { databaseId login } }"

      ACCESS_TOKEN_DATA=$(curl \
        -fsSL \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer ${GITHUB_TOKEN}" \
        -X POST \
        -d "{ \"query\": \"${QUERY}\"}" \
        https://api.github.com/graphql \
      )

      GIT_USERNAME=$(echo $ACCESS_TOKEN_DATA | jq -r '.data.viewer.login')
      ACCESS_TOKEN_ID=$(echo $ACCESS_TOKEN_DATA | jq -r '.data.viewer.databaseId')
      GIT_EMAIL="${ACCESS_TOKEN_ID}+${GIT_USERNAME}@users.noreply.github.com"

      git config user.email $GIT_EMAIL
      git config user.name $GIT_USERNAME
    env:
      CHECKOUT_PATH: ${{ params.path }}
      GITHUB_TOKEN: ${{ params.github-access-token }}
      PRESERVE_GIT_DIR: ${{ params.preserve-git-dir }}
